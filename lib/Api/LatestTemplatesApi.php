<?php
/**
 * LatestTemplatesApi
 * PHP version 5
 *
 * @category Class
 * @package  WheelSizeApiClient\Configurator
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Wheel Configurator API
 *
 * Wheel Configurator API is a part of Wheel Fitment API v2.  The Wheel Configurator API is a tool that allows users to visualize wheel  and tire upgrades on vehicles. It can be integrated into any website   or application to enhance the customer shopping experience by allowing them to visualize   their vehicle with different wheel options,    which can lead to increased sales and customer satisfaction.       **NOTE:** A _Configurator Template_ is a vehicle-specific image prepared  for custom rim installation via a URL or file upload.       [Demo](https://api-demo.wheel-size.com/),  [FAQs](https://api-demo.wheel-size.com/),
 *
 * OpenAPI spec version: v2
 * Contact: info@wheel-size.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.50
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace WheelSizeApiClient\Configurator\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WheelSizeApiClient\Configurator\ApiException;
use WheelSizeApiClient\Configurator\Configuration;
use WheelSizeApiClient\Configurator\HeaderSelector;
use WheelSizeApiClient\Configurator\ObjectSerializer;

/**
 * LatestTemplatesApi Class Doc Comment
 *
 * @category Class
 * @package  WheelSizeApiClient\Configurator
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LatestTemplatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation latestTemplatesList
     *
     * @param  string $make make (optional)
     * @param  string $model model (optional)
     * @param  string $generation generation (optional)
     * @param  int $year year (optional)
     * @param  string $body body (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit limit (optional, default to 50)
     * @param  int $offset offset (optional, default to 0)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\LatestTemplatesReportOutput
     */
    public function latestTemplatesList($make = null, $model = null, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        list($response) = $this->latestTemplatesListWithHttpInfo($make, $model, $generation, $year, $body, $ordering, $limit, $offset);
        return $response;
    }

    /**
     * Operation latestTemplatesListWithHttpInfo
     *
     * @param  string $make (optional)
     * @param  string $model (optional)
     * @param  string $generation (optional)
     * @param  int $year (optional)
     * @param  string $body (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\LatestTemplatesReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function latestTemplatesListWithHttpInfo($make = null, $model = null, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\LatestTemplatesReportOutput';
        $request = $this->latestTemplatesListRequest($make, $model, $generation, $year, $body, $ordering, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\LatestTemplatesReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation latestTemplatesListAsync
     *
     * 
     *
     * @param  string $make (optional)
     * @param  string $model (optional)
     * @param  string $generation (optional)
     * @param  int $year (optional)
     * @param  string $body (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function latestTemplatesListAsync($make = null, $model = null, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        return $this->latestTemplatesListAsyncWithHttpInfo($make, $model, $generation, $year, $body, $ordering, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation latestTemplatesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $make (optional)
     * @param  string $model (optional)
     * @param  string $generation (optional)
     * @param  int $year (optional)
     * @param  string $body (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function latestTemplatesListAsyncWithHttpInfo($make = null, $model = null, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\LatestTemplatesReportOutput';
        $request = $this->latestTemplatesListRequest($make, $model, $generation, $year, $body, $ordering, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'latestTemplatesList'
     *
     * @param  string $make (optional)
     * @param  string $model (optional)
     * @param  string $generation (optional)
     * @param  int $year (optional)
     * @param  string $body (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function latestTemplatesListRequest($make = null, $model = null, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {

        $resourcePath = '/latest-templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($make !== null) {
            $queryParams['make'] = ObjectSerializer::toQueryValue($make, null);
        }
        // query params
        if ($model !== null) {
            $queryParams['model'] = ObjectSerializer::toQueryValue($model, null);
        }
        // query params
        if ($generation !== null) {
            $queryParams['generation'] = ObjectSerializer::toQueryValue($generation, null);
        }
        // query params
        if ($year !== null) {
            $queryParams['year'] = ObjectSerializer::toQueryValue($year, null);
        }
        // query params
        if ($body !== null) {
            $queryParams['body'] = ObjectSerializer::toQueryValue($body, null);
        }
        // query params
        if ($ordering !== null) {
            $queryParams['ordering'] = ObjectSerializer::toQueryValue($ordering, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

<?php
/**
 * ConfiguratorApi
 * PHP version 5
 *
 * @category Class
 * @package  WheelSizeApiClient\Configurator
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Wheel Configurator API
 *
 * Wheel Configurator API is a part of Wheel Fitment API v2.  The Wheel Configurator API is a tool that allows users to visualize wheel  and tire upgrades on vehicles. It can be integrated into any website   or application to enhance the customer shopping experience by allowing them to visualize   their vehicle with different wheel options,    which can lead to increased sales and customer satisfaction.       **NOTE:** A _Configurator Template_ is a vehicle-specific image prepared  for custom rim installation via a URL or file upload.       [Demo](https://api-demo.wheel-size.com/),  [FAQs](https://api-demo.wheel-size.com/),
 *
 * OpenAPI spec version: v2
 * Contact: info@wheel-size.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.50
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace WheelSizeApiClient\Configurator\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WheelSizeApiClient\Configurator\ApiException;
use WheelSizeApiClient\Configurator\Configuration;
use WheelSizeApiClient\Configurator\HeaderSelector;
use WheelSizeApiClient\Configurator\ObjectSerializer;

/**
 * ConfiguratorApi Class Doc Comment
 *
 * @category Class
 * @package  WheelSizeApiClient\Configurator
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ConfiguratorApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation configuratorTemplate
     *
     * Get detailed info about selected Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\Body
     */
    public function configuratorTemplate($template)
    {
        list($response) = $this->configuratorTemplateWithHttpInfo($template);
        return $response;
    }

    /**
     * Operation configuratorTemplateWithHttpInfo
     *
     * Get detailed info about selected Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\Body, HTTP status code, HTTP response headers (array of strings)
     */
    public function configuratorTemplateWithHttpInfo($template)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\Body';
        $request = $this->configuratorTemplateRequest($template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\Body',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation configuratorTemplateAsync
     *
     * Get detailed info about selected Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplateAsync($template)
    {
        return $this->configuratorTemplateAsyncWithHttpInfo($template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation configuratorTemplateAsyncWithHttpInfo
     *
     * Get detailed info about selected Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplateAsyncWithHttpInfo($template)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\Body';
        $request = $this->configuratorTemplateRequest($template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'configuratorTemplate'
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function configuratorTemplateRequest($template)
    {
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling configuratorTemplate'
            );
        }

        $resourcePath = '/templates/{template}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($template !== null) {
            $resourcePath = str_replace(
                '{' . 'template' . '}',
                ObjectSerializer::toPathValue($template),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation configuratorTemplateColors
     *
     * Get A List of OE colors with names for a specific Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\TemplateColorsReportOutput
     */
    public function configuratorTemplateColors($template)
    {
        list($response) = $this->configuratorTemplateColorsWithHttpInfo($template);
        return $response;
    }

    /**
     * Operation configuratorTemplateColorsWithHttpInfo
     *
     * Get A List of OE colors with names for a specific Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\TemplateColorsReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function configuratorTemplateColorsWithHttpInfo($template)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\TemplateColorsReportOutput';
        $request = $this->configuratorTemplateColorsRequest($template);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\TemplateColorsReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation configuratorTemplateColorsAsync
     *
     * Get A List of OE colors with names for a specific Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplateColorsAsync($template)
    {
        return $this->configuratorTemplateColorsAsyncWithHttpInfo($template)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation configuratorTemplateColorsAsyncWithHttpInfo
     *
     * Get A List of OE colors with names for a specific Configurator Template ID
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplateColorsAsyncWithHttpInfo($template)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\TemplateColorsReportOutput';
        $request = $this->configuratorTemplateColorsRequest($template);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'configuratorTemplateColors'
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function configuratorTemplateColorsRequest($template)
    {
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling configuratorTemplateColors'
            );
        }

        $resourcePath = '/templates/{template}/colors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($template !== null) {
            $resourcePath = str_replace(
                '{' . 'template' . '}',
                ObjectSerializer::toPathValue($template),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation configuratorTemplateRimFit
     *
     * Generate an image of the Configurator Template (vehicle) with the specified rim
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     * @param  string $url The rim image URL you want to fit to the specified Configurator Template.   Image requirements:  * the rim should be slightly turned to the side  * min width:250px, min height:250px  Image Example: [link](https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png) (e.g. &#x60;https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png&#x60;) (optional)
     * @param  \SplFileObject $file The rim image you want to fit to the specified Configurator Template.  It can be in multipart HTML form content or raw binary format. (optional)
     * @param  string $color 6 Digit Hex RGB color.  For &#x27;EVOX&#x27; type of Configurator Templates use one of OE colors from _**&#x60;GET /templates/{template}/colors/&#x60;**_For &#x27;manual&#x27; type of Configurator Templates it can be any color. (e.g. &#x60;1e4b82&#x60;) (optional)
     * @param  int $brakes The composite image can be returned without or with a brake disk, black (default) or red caliper color can be specified. Possible values: &#x60;0&#x60;, &#x60;1&#x60; and &#x60;2&#x60;.  Where &#x60;0&#x60;- no brakes, &#x60;1&#x60;- black caliper, &#x60;2&#x60;- red.  If not specified, black caliper color is used. (e.g. &#x60;2&#x60;) (optional)
     * @param  int $rba_level Rim boundary smoothing level.  As parameter value is increased, the rim boundary blurring width is increased. The value must be odd. If omitted, level &#x60;17&#x60; is used. (e.g. &#x60;17&#x60;) (optional)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function configuratorTemplateRimFit($template, $url = null, $file = null, $color = null, $brakes = null, $rba_level = null)
    {
        $this->configuratorTemplateRimFitWithHttpInfo($template, $url, $file, $color, $brakes, $rba_level);
    }

    /**
     * Operation configuratorTemplateRimFitWithHttpInfo
     *
     * Generate an image of the Configurator Template (vehicle) with the specified rim
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     * @param  string $url The rim image URL you want to fit to the specified Configurator Template.   Image requirements:  * the rim should be slightly turned to the side  * min width:250px, min height:250px  Image Example: [link](https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png) (e.g. &#x60;https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png&#x60;) (optional)
     * @param  \SplFileObject $file The rim image you want to fit to the specified Configurator Template.  It can be in multipart HTML form content or raw binary format. (optional)
     * @param  string $color 6 Digit Hex RGB color.  For &#x27;EVOX&#x27; type of Configurator Templates use one of OE colors from _**&#x60;GET /templates/{template}/colors/&#x60;**_For &#x27;manual&#x27; type of Configurator Templates it can be any color. (e.g. &#x60;1e4b82&#x60;) (optional)
     * @param  int $brakes The composite image can be returned without or with a brake disk, black (default) or red caliper color can be specified. Possible values: &#x60;0&#x60;, &#x60;1&#x60; and &#x60;2&#x60;.  Where &#x60;0&#x60;- no brakes, &#x60;1&#x60;- black caliper, &#x60;2&#x60;- red.  If not specified, black caliper color is used. (e.g. &#x60;2&#x60;) (optional)
     * @param  int $rba_level Rim boundary smoothing level.  As parameter value is increased, the rim boundary blurring width is increased. The value must be odd. If omitted, level &#x60;17&#x60; is used. (e.g. &#x60;17&#x60;) (optional)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function configuratorTemplateRimFitWithHttpInfo($template, $url = null, $file = null, $color = null, $brakes = null, $rba_level = null)
    {
        $returnType = '';
        $request = $this->configuratorTemplateRimFitRequest($template, $url, $file, $color, $brakes, $rba_level);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation configuratorTemplateRimFitAsync
     *
     * Generate an image of the Configurator Template (vehicle) with the specified rim
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     * @param  string $url The rim image URL you want to fit to the specified Configurator Template.   Image requirements:  * the rim should be slightly turned to the side  * min width:250px, min height:250px  Image Example: [link](https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png) (e.g. &#x60;https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png&#x60;) (optional)
     * @param  \SplFileObject $file The rim image you want to fit to the specified Configurator Template.  It can be in multipart HTML form content or raw binary format. (optional)
     * @param  string $color 6 Digit Hex RGB color.  For &#x27;EVOX&#x27; type of Configurator Templates use one of OE colors from _**&#x60;GET /templates/{template}/colors/&#x60;**_For &#x27;manual&#x27; type of Configurator Templates it can be any color. (e.g. &#x60;1e4b82&#x60;) (optional)
     * @param  int $brakes The composite image can be returned without or with a brake disk, black (default) or red caliper color can be specified. Possible values: &#x60;0&#x60;, &#x60;1&#x60; and &#x60;2&#x60;.  Where &#x60;0&#x60;- no brakes, &#x60;1&#x60;- black caliper, &#x60;2&#x60;- red.  If not specified, black caliper color is used. (e.g. &#x60;2&#x60;) (optional)
     * @param  int $rba_level Rim boundary smoothing level.  As parameter value is increased, the rim boundary blurring width is increased. The value must be odd. If omitted, level &#x60;17&#x60; is used. (e.g. &#x60;17&#x60;) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplateRimFitAsync($template, $url = null, $file = null, $color = null, $brakes = null, $rba_level = null)
    {
        return $this->configuratorTemplateRimFitAsyncWithHttpInfo($template, $url, $file, $color, $brakes, $rba_level)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation configuratorTemplateRimFitAsyncWithHttpInfo
     *
     * Generate an image of the Configurator Template (vehicle) with the specified rim
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     * @param  string $url The rim image URL you want to fit to the specified Configurator Template.   Image requirements:  * the rim should be slightly turned to the side  * min width:250px, min height:250px  Image Example: [link](https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png) (e.g. &#x60;https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png&#x60;) (optional)
     * @param  \SplFileObject $file The rim image you want to fit to the specified Configurator Template.  It can be in multipart HTML form content or raw binary format. (optional)
     * @param  string $color 6 Digit Hex RGB color.  For &#x27;EVOX&#x27; type of Configurator Templates use one of OE colors from _**&#x60;GET /templates/{template}/colors/&#x60;**_For &#x27;manual&#x27; type of Configurator Templates it can be any color. (e.g. &#x60;1e4b82&#x60;) (optional)
     * @param  int $brakes The composite image can be returned without or with a brake disk, black (default) or red caliper color can be specified. Possible values: &#x60;0&#x60;, &#x60;1&#x60; and &#x60;2&#x60;.  Where &#x60;0&#x60;- no brakes, &#x60;1&#x60;- black caliper, &#x60;2&#x60;- red.  If not specified, black caliper color is used. (e.g. &#x60;2&#x60;) (optional)
     * @param  int $rba_level Rim boundary smoothing level.  As parameter value is increased, the rim boundary blurring width is increased. The value must be odd. If omitted, level &#x60;17&#x60; is used. (e.g. &#x60;17&#x60;) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplateRimFitAsyncWithHttpInfo($template, $url = null, $file = null, $color = null, $brakes = null, $rba_level = null)
    {
        $returnType = '';
        $request = $this->configuratorTemplateRimFitRequest($template, $url, $file, $color, $brakes, $rba_level);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'configuratorTemplateRimFit'
     *
     * @param  int $template Numeric ID of the Configurator Template (e.g. &#x60;448&#x60;) (required)
     * @param  string $url The rim image URL you want to fit to the specified Configurator Template.   Image requirements:  * the rim should be slightly turned to the side  * min width:250px, min height:250px  Image Example: [link](https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png) (e.g. &#x60;https://configurator.wheel-size.com/media/public/ENKEI-T6R-Gloss.png&#x60;) (optional)
     * @param  \SplFileObject $file The rim image you want to fit to the specified Configurator Template.  It can be in multipart HTML form content or raw binary format. (optional)
     * @param  string $color 6 Digit Hex RGB color.  For &#x27;EVOX&#x27; type of Configurator Templates use one of OE colors from _**&#x60;GET /templates/{template}/colors/&#x60;**_For &#x27;manual&#x27; type of Configurator Templates it can be any color. (e.g. &#x60;1e4b82&#x60;) (optional)
     * @param  int $brakes The composite image can be returned without or with a brake disk, black (default) or red caliper color can be specified. Possible values: &#x60;0&#x60;, &#x60;1&#x60; and &#x60;2&#x60;.  Where &#x60;0&#x60;- no brakes, &#x60;1&#x60;- black caliper, &#x60;2&#x60;- red.  If not specified, black caliper color is used. (e.g. &#x60;2&#x60;) (optional)
     * @param  int $rba_level Rim boundary smoothing level.  As parameter value is increased, the rim boundary blurring width is increased. The value must be odd. If omitted, level &#x60;17&#x60; is used. (e.g. &#x60;17&#x60;) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function configuratorTemplateRimFitRequest($template, $url = null, $file = null, $color = null, $brakes = null, $rba_level = null)
    {
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling configuratorTemplateRimFit'
            );
        }

        $resourcePath = '/templates/{template}/fit/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url, null);
        }
        // query params
        if ($file !== null) {
            $queryParams['file'] = ObjectSerializer::toQueryValue($file, null);
        }
        // query params
        if ($color !== null) {
            $queryParams['color'] = ObjectSerializer::toQueryValue($color, null);
        }
        // query params
        if ($brakes !== null) {
            $queryParams['brakes'] = ObjectSerializer::toQueryValue($brakes, null);
        }
        // query params
        if ($rba_level !== null) {
            $queryParams['rba_level'] = ObjectSerializer::toQueryValue($rba_level, null);
        }

        // path params
        if ($template !== null) {
            $resourcePath = str_replace(
                '{' . 'template' . '}',
                ObjectSerializer::toPathValue($template),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation configuratorTemplates
     *
     * Get A List of Configurator Templates
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $generation Slug of the vehicle generation. (e.g. &#x60;fd3ae75350&#x60;) (optional)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $body Body slug of the vehicle generation. Use _**&#x60;GET /generations/&#x60;**_ to get list of generations with bodies (e.g. &#x60;b7c386cf60&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit limit (optional, default to 50)
     * @param  int $offset offset (optional, default to 0)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\TemplatesReportOutput
     */
    public function configuratorTemplates($make, $model, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        list($response) = $this->configuratorTemplatesWithHttpInfo($make, $model, $generation, $year, $body, $ordering, $limit, $offset);
        return $response;
    }

    /**
     * Operation configuratorTemplatesWithHttpInfo
     *
     * Get A List of Configurator Templates
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $generation Slug of the vehicle generation. (e.g. &#x60;fd3ae75350&#x60;) (optional)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $body Body slug of the vehicle generation. Use _**&#x60;GET /generations/&#x60;**_ to get list of generations with bodies (e.g. &#x60;b7c386cf60&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\TemplatesReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function configuratorTemplatesWithHttpInfo($make, $model, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\TemplatesReportOutput';
        $request = $this->configuratorTemplatesRequest($make, $model, $generation, $year, $body, $ordering, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\TemplatesReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation configuratorTemplatesAsync
     *
     * Get A List of Configurator Templates
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $generation Slug of the vehicle generation. (e.g. &#x60;fd3ae75350&#x60;) (optional)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $body Body slug of the vehicle generation. Use _**&#x60;GET /generations/&#x60;**_ to get list of generations with bodies (e.g. &#x60;b7c386cf60&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplatesAsync($make, $model, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        return $this->configuratorTemplatesAsyncWithHttpInfo($make, $model, $generation, $year, $body, $ordering, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation configuratorTemplatesAsyncWithHttpInfo
     *
     * Get A List of Configurator Templates
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $generation Slug of the vehicle generation. (e.g. &#x60;fd3ae75350&#x60;) (optional)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $body Body slug of the vehicle generation. Use _**&#x60;GET /generations/&#x60;**_ to get list of generations with bodies (e.g. &#x60;b7c386cf60&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configuratorTemplatesAsyncWithHttpInfo($make, $model, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\TemplatesReportOutput';
        $request = $this->configuratorTemplatesRequest($make, $model, $generation, $year, $body, $ordering, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'configuratorTemplates'
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $generation Slug of the vehicle generation. (e.g. &#x60;fd3ae75350&#x60;) (optional)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $body Body slug of the vehicle generation. Use _**&#x60;GET /generations/&#x60;**_ to get list of generations with bodies (e.g. &#x60;b7c386cf60&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;make&#x60;*, *&#x60;model&#x60;* (optional)
     * @param  int $limit (optional, default to 50)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function configuratorTemplatesRequest($make, $model, $generation = null, $year = null, $body = null, $ordering = null, $limit = '50', $offset = '0')
    {
        // verify the required parameter 'make' is set
        if ($make === null || (is_array($make) && count($make) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $make when calling configuratorTemplates'
            );
        }
        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling configuratorTemplates'
            );
        }

        $resourcePath = '/templates/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($make !== null) {
            $queryParams['make'] = ObjectSerializer::toQueryValue($make, null);
        }
        // query params
        if ($model !== null) {
            $queryParams['model'] = ObjectSerializer::toQueryValue($model, null);
        }
        // query params
        if ($generation !== null) {
            $queryParams['generation'] = ObjectSerializer::toQueryValue($generation, null);
        }
        // query params
        if ($year !== null) {
            $queryParams['year'] = ObjectSerializer::toQueryValue($year, null);
        }
        // query params
        if ($body !== null) {
            $queryParams['body'] = ObjectSerializer::toQueryValue($body, null);
        }
        // query params
        if ($ordering !== null) {
            $queryParams['ordering'] = ObjectSerializer::toQueryValue($ordering, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generations
     *
     * Get A List of Car Generations
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;start&#x60;* (optional)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\GenerationsReportOutput
     */
    public function generations($make, $model, $year = null, $ordering = null)
    {
        list($response) = $this->generationsWithHttpInfo($make, $model, $year, $ordering);
        return $response;
    }

    /**
     * Operation generationsWithHttpInfo
     *
     * Get A List of Car Generations
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;start&#x60;* (optional)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\GenerationsReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function generationsWithHttpInfo($make, $model, $year = null, $ordering = null)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\GenerationsReportOutput';
        $request = $this->generationsRequest($make, $model, $year, $ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\GenerationsReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generationsAsync
     *
     * Get A List of Car Generations
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;start&#x60;* (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generationsAsync($make, $model, $year = null, $ordering = null)
    {
        return $this->generationsAsyncWithHttpInfo($make, $model, $year, $ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generationsAsyncWithHttpInfo
     *
     * Get A List of Car Generations
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;start&#x60;* (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generationsAsyncWithHttpInfo($make, $model, $year = null, $ordering = null)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\GenerationsReportOutput';
        $request = $this->generationsRequest($make, $model, $year, $ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generations'
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;start&#x60;* (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generationsRequest($make, $model, $year = null, $ordering = null)
    {
        // verify the required parameter 'make' is set
        if ($make === null || (is_array($make) && count($make) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $make when calling generations'
            );
        }
        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling generations'
            );
        }

        $resourcePath = '/generations/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($make !== null) {
            $queryParams['make'] = ObjectSerializer::toQueryValue($make, null);
        }
        // query params
        if ($model !== null) {
            $queryParams['model'] = ObjectSerializer::toQueryValue($model, null);
        }
        // query params
        if ($year !== null) {
            $queryParams['year'] = ObjectSerializer::toQueryValue($year, null);
        }
        // query params
        if ($ordering !== null) {
            $queryParams['ordering'] = ObjectSerializer::toQueryValue($ordering, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation makes
     *
     * Get A List of Makes
     *
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional, default to slug)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\MakesReportOutput
     */
    public function makes($year = null, $ordering = 'slug')
    {
        list($response) = $this->makesWithHttpInfo($year, $ordering);
        return $response;
    }

    /**
     * Operation makesWithHttpInfo
     *
     * Get A List of Makes
     *
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional, default to slug)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\MakesReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function makesWithHttpInfo($year = null, $ordering = 'slug')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\MakesReportOutput';
        $request = $this->makesRequest($year, $ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\MakesReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation makesAsync
     *
     * Get A List of Makes
     *
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional, default to slug)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makesAsync($year = null, $ordering = 'slug')
    {
        return $this->makesAsyncWithHttpInfo($year, $ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation makesAsyncWithHttpInfo
     *
     * Get A List of Makes
     *
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional, default to slug)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function makesAsyncWithHttpInfo($year = null, $ordering = 'slug')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\MakesReportOutput';
        $request = $this->makesRequest($year, $ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'makes'
     *
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional, default to slug)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function makesRequest($year = null, $ordering = 'slug')
    {

        $resourcePath = '/makes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($year !== null) {
            $queryParams['year'] = ObjectSerializer::toQueryValue($year, null);
        }
        // query params
        if ($ordering !== null) {
            $queryParams['ordering'] = ObjectSerializer::toQueryValue($ordering, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation models
     *
     * Get A List of Models via Different Filters
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\ModelsReportOutput
     */
    public function models($make, $year = null, $ordering = null)
    {
        list($response) = $this->modelsWithHttpInfo($make, $year, $ordering);
        return $response;
    }

    /**
     * Operation modelsWithHttpInfo
     *
     * Get A List of Models via Different Filters
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\ModelsReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function modelsWithHttpInfo($make, $year = null, $ordering = null)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\ModelsReportOutput';
        $request = $this->modelsRequest($make, $year, $ordering);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\ModelsReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modelsAsync
     *
     * Get A List of Models via Different Filters
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modelsAsync($make, $year = null, $ordering = null)
    {
        return $this->modelsAsyncWithHttpInfo($make, $year, $ordering)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modelsAsyncWithHttpInfo
     *
     * Get A List of Models via Different Filters
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modelsAsyncWithHttpInfo($make, $year = null, $ordering = null)
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\ModelsReportOutput';
        $request = $this->modelsRequest($make, $year, $ordering);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'models'
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (required)
     * @param  string $year Year. Use _**&#x60;GET /years/&#x60;**_ to get the model years of a specific car make/model  (e.g. &#x60;2022&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function modelsRequest($make, $year = null, $ordering = null)
    {
        // verify the required parameter 'make' is set
        if ($make === null || (is_array($make) && count($make) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $make when calling models'
            );
        }

        $resourcePath = '/models/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($make !== null) {
            $queryParams['make'] = ObjectSerializer::toQueryValue($make, null);
        }
        // query params
        if ($year !== null) {
            $queryParams['year'] = ObjectSerializer::toQueryValue($year, null);
        }
        // query params
        if ($ordering !== null) {
            $queryParams['ordering'] = ObjectSerializer::toQueryValue($ordering, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation years
     *
     * Get A List of Years
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (optional)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     * @param  int $limit limit (optional, default to 100)
     * @param  int $offset offset (optional, default to 0)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WheelSizeApiClient\Configurator\Model\YearsReportOutput
     */
    public function years($make = null, $model = null, $ordering = null, $limit = '100', $offset = '0')
    {
        list($response) = $this->yearsWithHttpInfo($make, $model, $ordering, $limit, $offset);
        return $response;
    }

    /**
     * Operation yearsWithHttpInfo
     *
     * Get A List of Years
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (optional)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     * @param  int $limit (optional, default to 100)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \WheelSizeApiClient\Configurator\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WheelSizeApiClient\Configurator\Model\YearsReportOutput, HTTP status code, HTTP response headers (array of strings)
     */
    public function yearsWithHttpInfo($make = null, $model = null, $ordering = null, $limit = '100', $offset = '0')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\YearsReportOutput';
        $request = $this->yearsRequest($make, $model, $ordering, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WheelSizeApiClient\Configurator\Model\YearsReportOutput',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation yearsAsync
     *
     * Get A List of Years
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (optional)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     * @param  int $limit (optional, default to 100)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function yearsAsync($make = null, $model = null, $ordering = null, $limit = '100', $offset = '0')
    {
        return $this->yearsAsyncWithHttpInfo($make, $model, $ordering, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation yearsAsyncWithHttpInfo
     *
     * Get A List of Years
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (optional)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     * @param  int $limit (optional, default to 100)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function yearsAsyncWithHttpInfo($make = null, $model = null, $ordering = null, $limit = '100', $offset = '0')
    {
        $returnType = '\WheelSizeApiClient\Configurator\Model\YearsReportOutput';
        $request = $this->yearsRequest($make, $model, $ordering, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'years'
     *
     * @param  string $make Slug of the **&#x60;Make&#x60;**. A car&#x27;s **&#x60;Make&#x60;** is the brand of the vehicle. Use _**&#x60;GET /makes/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;bmw&#x60;) (optional)
     * @param  string $model Slug of the **&#x60;Model&#x60;**. The particular **&#x60;Model&#x60;** of the brand. Use _**&#x60;GET /models/&#x60;**_ to get a list of available *&#x60;slug&#x60;* values. (e.g. &#x60;x6&#x60;) (optional)
     * @param  string $ordering Comma-separated list without spaces. Supported field names: *&#x60;slug&#x60;* (optional)
     * @param  int $limit (optional, default to 100)
     * @param  int $offset (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function yearsRequest($make = null, $model = null, $ordering = null, $limit = '100', $offset = '0')
    {

        $resourcePath = '/years/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($make !== null) {
            $queryParams['make'] = ObjectSerializer::toQueryValue($make, null);
        }
        // query params
        if ($model !== null) {
            $queryParams['model'] = ObjectSerializer::toQueryValue($model, null);
        }
        // query params
        if ($ordering !== null) {
            $queryParams['ordering'] = ObjectSerializer::toQueryValue($ordering, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('user_key');
        if ($apiKey !== null) {
            $queryParams['user_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
